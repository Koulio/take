/**
 * Copyright 2007 Jens Dietrich Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
 * Unless required by applicable law or agreed to in writing, software distributed under the 
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied. See the License for the specific language governing permissions 
 * and limitations under the License.
 */

package nz.org.take.compiler.reference;

import java.beans.XMLEncoder;
import java.io.PrintWriter;
import java.util.*;
import java.util.Map.Entry;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import nz.org.take.compiler.*;
import nz.org.take.compiler.Compiler;
import nz.org.take.compiler.util.*;
import nz.org.take.rt.DerivationController;
import nz.org.take.rt.SingletonIterator;
import nz.org.take.*;

/**
 * Default compiler implementation.
 * @author <a href="http://www-ist.massey.ac.nz/JBDietrich/">Jens Dietrich</a>
 */

public class DefaultCompiler extends CompilerUtils  implements Compiler {
	
	private static final String RESULT = "result";
	// file name for the resource where the annotations are stored
	private static final String ANNOTATION_STORE = "annotations.xml";
	// under this pseudo id global annotations will be stored
	private static final String GLOBAL_ANNOTATION_KEY = "___global_annotations";
	
	
	// instance variable names
	private String varName4DerivationController = "_derivation";

	// custom settings
	private String derivationControllerClass = "DefaultDerivationController";
	private boolean autoAnnotate = false;
	private String[] derivationControllerInitialisationParameters = {}; // will be passed to the constructor of derivationControllerClass
	private List<Query> publicAgenda = new ArrayList<Query>();
	private Collection<Query> done = new ArrayList<Query>();
	private NameGenerator nameGenerator = new DefaultNameGenerator();
	private KnowledgeBase kb = null;
	private List<SourceTransformation> transformations = new ArrayList<SourceTransformation>();
	private Map<DerivationRule, String> bindingClassNames = new HashMap<DerivationRule, String>();
	private int bindingClassCounter = 1;
	private Map<String,ExternalFactStore> externalFactStores = null;
	private List<CompilerPlugin> plugins = new ArrayList<CompilerPlugin>();
	private Location location = new DefaultLocation();
	private String packageName = null;
	private String className = "_KB";
	private String[] interfaceNames = null;
	private String[] importStatements = null;
	private boolean generateDataClassesForQueryPredicates = true;
	private Set<Predicate> publicPredicates = null; // predicates referenced in queries
	private Map<String,PrintWriter> classWriters = new HashMap<String,PrintWriter>();
	private Map<Expression,String> expressionDefs = new HashMap<Expression,String>();
	private Map<Aggregations,AggregationFunctionGenerator> aggregationFunctionGenerators = new HashMap<Aggregations,AggregationFunctionGenerator>();
	private Collection<Predicate> predicateClassesGenerated = new HashSet<Predicate>();
	private Map<Expression,String> expressionPrereqMethodRefs = new HashMap<Expression,String>();
	private Map<Expression,String> expressionPrereqMethodTypes = new HashMap<Expression,String>();
	private Map<List<Class>,String> expressionPrereqMethodTypesCache = new HashMap<List<Class>,String>();
	
	/**
	 * Constructor.
	 */
	public DefaultCompiler()  {
		super();
		this.install(new CompilerPlugin4NAFNegatedSimplePredicates(this));
		this.install(new AggregationFunctionGeneratorSUM());
		this.install(new AggregationFunctionGeneratorMIN());
		this.install(new AggregationFunctionGeneratorMAX());
		this.install(new AggregationFunctionGeneratorCOUNT());
		this.install(new AggregationFunctionGeneratorAVG());
	}

	/**
	 * Create a public interface for the knowledge base.
	 * This method will create an interface containing the public methods of the kb to be generated by the kb.
	 * it will also create the referenced types - the data types for the predicates referenced in the queries.
	 * @param kb a knowledge base
	 * @throws CompilerException
	 */
	public void compileInterface (KnowledgeBase kb) throws CompilerException  {
		this.kb = kb;
		// step1 - return types
		for (Predicate p:getPublicPredicates()) {
			createReturnType(p);
		}
		for (ExternalFactStore fs:getExternalFactStores().values()) {
			createReturnType(fs.getPredicate());
		}
		
		// step2 - interfaces for external fact sets
		for (Map.Entry<String,ExternalFactStore>entry:this.getExternalFactStores().entrySet()) {
			String pClassName = getExternalDataStoreName(entry.getValue());
			String fullClassName = packageName +'.'+pClassName;
			PrintWriter out = new PrintWriter(location.getSrcOut(fullClassName));
			createExternalFactStoreType(out, pClassName, packageName, entry.getValue());
			out.close();
			endorseClazz(location, fullClassName);
		}
		
		// step2 - interface
		PrintWriter out = new PrintWriter(location.getSrcOut( packageName + "." + className));
		out.print("package ");
		out.print(packageName);
		out.println(";");
		out.println("import nz.org.take.rt.*;");
		
		// print additional imports
		printImports(out);
		
		out.println("/**");
		out.println(" * Interface generated by the take compiler. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("public interface ");
		out.print(className);
		
		if (this.interfaceNames!=null && this.interfaceNames.length>0) {
			out.print(" extends ");
			printCommaSeparatedList(out,this.interfaceNames);
		}
		
		out.println("{");
		// abstract methods
		for (Query q:kb.getQueries()) {
			createPublicMethod(out,q,false,false);
		}

		// add meta data registry
		createAnnotationMethod(out,true);
		
		out.println("}");
		out.close();
		String fullClassName = packageName + "." + className;
		endorseClazz(location, fullClassName);
		
		this.nameGenerator.reset();
	}

	/**
	 * Compile the kb.
	 * @param kb a knowledge base
	 * @throws CompilerException
	 */
	public void compile(KnowledgeBase kb)throws CompilerException {

		if (this.isAutoAnnotate()) {
			AutoAnnotationService.annotateAll(kb);
		}
		// put queries to publicAgenda (necessity is checked implicit)
		for (Query q : kb.getQueries()) {
			q.setPublic(true);
			this.addToAgenda(q);
			// cache method names from annotation so that queries that are built later
			// can use the same annotations
			String methodName = q.getAnnotation(AnnotationKeys.TAKE_GENERATE_METHOD);
		}
		String fullClassName = null;
		String constantRegistryClassName = packageName + "." + nameGenerator.getConstantRegistryClassName();
		String factStoreRegistryClassName = packageName + "." + nameGenerator.getFactStoreRegistryClassName();
		String aggregationFunctionsRegistryClassName = packageName + "." + nameGenerator.getAggregationFunctionsRegistryClassName();
		String expressionRegistryClassName  = packageName + "." + nameGenerator.getExpressionRegistryClassName();
		this.kb = kb;
		PrintWriter out = null;
		try {
			// build registries
			
			Collection<Constant> constants = this.findConstants();
			if (!constants.isEmpty()) {
				out = new PrintWriter(location.getSrcOut(constantRegistryClassName));
				createConstantsRegistryClass(out,constants,nameGenerator.getConstantRegistryClassName(), packageName);
				out.close();
			}
			
			Collection<AggregationFunction> aggregationFunctions = this.findAggregationFunctions();
			if (!aggregationFunctions.isEmpty()) {
				out = new PrintWriter(location.getSrcOut(aggregationFunctionsRegistryClassName));
				this.createAggregationFunctionsRegistryClass(out,aggregationFunctions,nameGenerator.getAggregationFunctionsRegistryClassName(), packageName);			
				out.close();
			}

			Collection<ExternalFactStore> externalFactStores = this.findExternalFactStores();
			if (!externalFactStores.isEmpty()){
				out = new PrintWriter(location.getSrcOut(factStoreRegistryClassName));
				createExternalFactStoresRegistryClass(out,externalFactStores,nameGenerator.getFactStoreRegistryClassName(), packageName);
				out.close();
			}
			
			Collection<Expression> expressions = this.findExpressions();
			if (!expressions.isEmpty()){
				TmpVarGenerator varGen = new TmpVarGenerator();
				for (Expression expression:expressions) {
					expressionDefs.put(expression,varGen.nextTmpVar("expression"));
				}
				out = new PrintWriter(location.getSrcOut(expressionRegistryClassName));
				this.createExpressionRegistryClass(out, expressionDefs, nameGenerator.getExpressionRegistryClassName(), packageName);
				out.close();
				endorseClazz(location, packageName+"."+nameGenerator.getExpressionRegistryClassName());
			}
			
			// build return types
			Collection<Predicate> predicates = findPredicates(kb);	
			checkCompilerHints(predicates);
			
			for (Predicate p:predicates) {
				if (!isGenerateDataClassesForQueryPredicates() && (this.getPublicPredicates().contains(p) || isUsedInFactStore(p))) {
					// already generated with interface
				}
				else {	
					createReturnType(p);
				}
			}

			
			// build public main kb class
			fullClassName = packageName + "." + this.className;
			out = new PrintWriter(location.getSrcOut(fullClassName));
			this.classWriters.put(className, out);
			createMainKBClass(out, className, packageName);
			// add meta data registry
			createAnnotationMethod(out,false);
			
			// public methods for queries
			for (Query q:kb.getQueries()) {
				this.createPublicMethod(out, q, true, false);
			}
			out.println('}');
			out.close();
			endorseClazz(location, fullClassName);
			
			// this is the important part where the recursion takes place recursion
			while (!this.isAgendaEmpty()) {
				Query nextQuery = this.getNextQuery();
				String fragementClassName = getKBFragementClassName(nextQuery);
				PrintWriter cout = this.getPrintWriter(fragementClassName);
				createMethod(cout, fragementClassName,this.getNextQuery());
				cout.flush();
			}
			
			// close and endorse main and fragment classes
			for (Entry<String,PrintWriter> e:classWriters.entrySet()) {
				e.getValue().println();
				e.getValue().println('}');
				e.getValue().close();
				endorseClazz(location, packageName + "." + e.getKey());
			}



		} catch (Exception x) {
			this.logger.error("a compiler exception has occurred",x);
			throw new CompilerException(x);
		}
		finally {
			this.nameGenerator.reset();
		}
	}

	private boolean isUsedInFactStore(Predicate p) {
		for (ExternalFactStore fs:getExternalFactStores().values()) {
			if (p.equals(fs.getPredicate()))
					return true;
		}
		return false;
	}

	// check the compiler hint annotations of the predicates
	// make sure that all predicates (in particular negated predicates)
	// with the same name / signature have the same compiler hint annotations 
	// 
	private void checkCompilerHints(Collection<Predicate> predicates) {
		Collection<Predicate> nafNegatedPredicates = new ArrayList<Predicate>();
		for (Predicate p:predicates) {
			if (p instanceof Predicate && p.isNegated()) {
				for (Predicate p2:predicates) {
					if (p!=p2 && p2.getName().equals(p.getName()) && Arrays.equals(p.getSlotTypes(),p2.getSlotTypes())) {
						String ann = p2.getAnnotation(AnnotationKeys.TAKE_GENERATE_CLASS);
						if (ann!=null) p.addAnnotation(AnnotationKeys.TAKE_GENERATE_CLASS, ann);
						ann = p2.getAnnotation(AnnotationKeys.TAKE_GENERATE_METHOD);
						if (ann!=null) p.addAnnotation(AnnotationKeys.TAKE_GENERATE_METHOD, ann);
						ann = p2.getAnnotation(AnnotationKeys.TAKE_GENERATE_SLOTS);
						if (ann!=null) {
							p.addAnnotation(AnnotationKeys.TAKE_GENERATE_SLOTS, ann);
							StringTokenizer tok = new StringTokenizer(ann,",");
							int size = tok.countTokens();
							String[] paramNames = new String[size];
							int i=0;
							while (tok.hasMoreTokens()) {
								paramNames[i]=tok.nextToken();
								i=i+1;
							}
							((Predicate)p).setSlotNames(paramNames);
						}
					}
				}
			}
		}
		
		
		
	}

	/**
	 * Create the class that holds the constants referenced in the kb.
	 * @param out the writer
	 * @param constants the constants
	 * @param clazz the class name
	 * @param pck the package name
	 */
	private void createConstantsRegistryClass(PrintWriter out, Collection<Constant> constants, String clazz, String pck) throws CompilerException {
		out.print("package ");
		out.print(pck);
		out.println(";");
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.println(" * This class holds the constants referenced in the knowledge base. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("public class ");
		out.print(clazz);
		out.println("{");

		for (Constant c:constants) {
			out.print("public static ");
			out.print(c.getType().getName());
			out.print(" ");
			out.print(c.getRef());
			out.println(';');
		}
		
		out.println("}");
	}
	
	/**
	 * Create the class that holds the compiled constants referenced in the kb.
	 * @param out the writer
	 * @param expressions the constants
	 * @param clazz the class name
	 * @param pck the package name
	 */
	private void createExpressionRegistryClass(PrintWriter out, Map<Expression,String> expressions, String clazz, String pck) throws CompilerException {
		out.print("package ");
		out.print(pck);
		out.println(";");
		out.println("import nz.org.take.rt.*;");
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.println(" * This class holds the expressions referenced in the knowledge base. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("public class ");
		out.print(clazz);
		out.println("{");

		// data types used to represent results of expression invocation

		for (Expression x:expressions.keySet()) {
			
			this.printOneLineComment(out,"compiled expression \"",x.getExpression(),"\"");
			x.generateDefinitionCode(out, expressions.get(x));
			out.println();
			
			List<Class> types = x.getVariableTypes();
			String reusableClassName = expressionPrereqMethodTypesCache.get(types);
			String invocationReturnType = null;
			
			if (reusableClassName==null) {
				this.printOneLineComment(out,"return type for invoking the expression \"",x.getExpression(),"\"");
				invocationReturnType = expressions.get(x)+"Type";
				this.expressionPrereqMethodTypes.put(x,clazz+"."+invocationReturnType);
				this.expressionPrereqMethodTypesCache.put(types,invocationReturnType);
				out.print("static class ");
				out.print(invocationReturnType);
				out.print(" ");
				out.println("{");
				for (Variable v:x.getVariables()) {
					out.print(v.getType().getName());
					out.print(" ");
					out.print(v.getName());
					out.println(";");
				}
				out.println("}");
			}
			else {
				this.printOneLineComment(out,"no new return types needed for expression \"",x.getExpression(),"\", reusing ",reusableClassName);
				out.println();
				this.expressionPrereqMethodTypes.put(x,clazz+"."+reusableClassName);
				invocationReturnType = reusableClassName;
			}
			

			
			this.printOneLineComment(out,"invocation of expression \"",x.getExpression(),"\"");
			List<String> args = x.getInputSlots();
			out.print("static ResourceIterator<");
			out.print(invocationReturnType);
			out.print("> ");
			String methodName = expressions.get(x)+"Invocation";
			out.print(methodName);
			this.expressionPrereqMethodRefs.put(x,clazz+"."+methodName);
			out.print("("); 
			boolean first = true;
			for (Variable v:x.getVariables()) {
				if (first) first=false;
				else out.print(",");
				out.print(v.getType().getName());
				out.print(" ");
				out.print(v.getName());
			}
			// derivation controller
			out.print(", final DerivationController _derivation");
			out.println("){");
			
	    	// print log statement
	        out.print("_derivation.log(\"");
	        out.print(x.getExpression());
	        out.println("\", DerivationController.EXPRESSION);");
	        
			String var = "result";
			this.printVariableDeclaration(out, null, "boolean", var, "false");
			String expressionField = expressions.get(x);
			x.generateInvocationCode(out,var,clazz,expressionField,new TmpVarGenerator(),args);
			
			// check, and if it fails, return empty iterator
			out.print("if (!");
			out.print(var);
			out.println(") {");
			out.println("return EmptyIterator.DEFAULT;");
			out.println("}");
			
			out.println("else {");
			out.print(invocationReturnType);
			out.print(" resultRecord = new ");
			out.print(invocationReturnType);
			out.println("();");
			
			for (Variable v:x.getVariables()) {
				out.print("resultRecord.");
				out.print(v.getName());
				out.print("=");
				out.print(v.getName());
				out.println(";");
			}
			
			out.print("return new SingletonIterator<");
			out.print(invocationReturnType);
			out.println(">(resultRecord);");
			out.println("}");
			
			
			out.println("}");
			
			out.println();
			out.println();
			
		}
		
		out.println("}");
	}
	
	/**
	 * Create the class that holds the aggregations referenced in the kb.
	 * @param out the writer
	 * @param functions the functions
	 * @param clazz the class name
	 * @param pck the package name
	 */
	private void createAggregationFunctionsRegistryClass(PrintWriter out, Collection<AggregationFunction> functions, String clazz, String pck) throws CompilerException {
		out.print("package ");
		out.print(pck);
		out.println(";");
		
		// print additional imports
		printImports(out);
		
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.println(" * In this class the aggregation functions referenced in the knowledge base are defined. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("public class ");
		out.print(clazz);
		out.println("{");

		for (AggregationFunction f:functions) {
			// build the query and the variable list
			//Query q = new Query();
			//q.setPredicate(f.getQuery().getPredicate());
			//boolean[] io = new boolean[q.getPredicate().getSlotTypes().length];
			//for (int i=0;i<io.length;i++) {
			//	io[i] = i!=f.getVariableSlot();
			//}
			//q.setInputParams(io);
			//this.addToAgenda(q);
			AggregationFunctionGenerator gen = this.aggregationFunctionGenerators.get(f.getAggregation());
			if (gen==null) throw new CompilerException("Code generation for aggregation function " + f.getAggregation() + " is not yet supported - no generator installed");
			Query q = gen.createAggregationFunction(out, f, this);
			this.addToAgenda(q);
		}
		
		out.println("}");
	}
	
	/**
	 * Create the class that holds the fact stores referenced in the kb.
	 * @param out the writer
	 * @param factStores the fact stores
	 * @param clazz the class name
	 * @param pck the package name
	 */
	private void createExternalFactStoresRegistryClass(PrintWriter out,Collection<ExternalFactStore> factStores, String clazz, String pck) throws CompilerException {
		
		out.print("package ");
		out.print(pck);
		out.println(";");
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.println(" * This class holds the fact stores referenced in the knowledge base. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("public class ");
		out.print(clazz);
		out.println("{");
		
		// the package name of the type referenced is the package
		// name of the interface
	
		for (ExternalFactStore fs:factStores) {
			String pClassName = getExternalDataStoreName(fs);
			
			// look for package where interfaces are located
			String fullClassName = null;
			if (this.interfaceNames==null)
				throw new CompilerException("Cannot find interface for external fact stores - no interface package set");
			
			for (String i:this.interfaceNames) {
				try {
					Class intfc = Class.forName(i);
					String iPck = intfc.getPackage().getName();
					String fpClassName = iPck+'.'+pClassName;
					try {
						Class.forName(fpClassName);
						fullClassName=fpClassName;
					}
					catch (ClassNotFoundException x) {}
				}
				catch (ClassNotFoundException x) {
					throw new CompilerException("Cannot find interface for external fact store " + i);
				}
			}
			
			if (fullClassName==null) 
				throw new CompilerException();
			
			out.print("public static ");
			out.print(fullClassName);
			out.print(" ");
			out.print(fs.getId());
			out.println("=null;");
		}
		
		out.println("}");
	}
	
	/**
	 * Create the main kb class. This is the class that has the public methods.
	 * @param out the writer
	 * @param clazz the class name
	 * @param pck the package name
	 */
	private void createMainKBClass(PrintWriter out, String clazz, String pck)
			throws CompilerException {
		out.print("package ");
		out.print(pck);
		out.println(";");
		out.println("import nz.org.take.rt.*;");
		
		// print additional imports
		printImports(out);
		
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("public class ");
		out.print(clazz);
		
		if (this.interfaceNames!=null && this.interfaceNames.length>0) {
			out.print(" implements ");
			printCommaSeparatedList(out,this.interfaceNames);
		}
		out.println("{");
	}
	
	/**
	 * Create a kb fragment class.
	 * @param out the writer
	 * @param clazz the class name
	 * @param pck the package name
	 */
	private void createKBFragmentClass(PrintWriter out, String clazz, String pck)
			throws CompilerException {
		out.print("package ");
		out.print(pck);
		out.println(";");
		out.println("import nz.org.take.rt.*;");
		
		// print additional imports
		printImports(out);
		
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");
		out.println("@SuppressWarnings(\"unchecked\")");
		out.print("class ");
		out.print(clazz);
		
		// fragments do not implement interfaces!

		out.println("{");
	}
	

	/**
	 * Create a class that can be used to keep track of variable bindings in rules.
	 * @param out the writer
	 * @param r  the rule
	 * @return a map associating variables with instance variable names
	 */
	private Map<Term, String> createBindingClass(PrintWriter out, DerivationRule r) throws CompilerException {
		Map<Term, String> map = new HashMap<Term, String>();
		this.printOneLineComment(out, "Variable bindings in rule: ", r);
		String name = this.getBindingClassName(r);
		out.print("class ");
		out.print(name);
		out.println('{');
		int counter = 1;
		Collection<Term> termsInRule = this.getAllTerms(r);		
		for (Term t : termsInRule) {
			if (!map.containsKey(t)) {
					String property = "p" + counter;
					counter = counter + 1;
					map.put(t, property);
					this.printOneLineComment(out,	"Property generated for term  \"", t,"\"");
					out.print(this.getTypeName(t.getType()));
					out.print(" ");
					out.print(property);
					out.println(";");
				}
			} 

		out.println("};");
		return map;
	}
	
	/**
	 * Create a class for a return type. 
	 * @param out  the writer
	 * @param clazz   the class name
	 * @param pck the package name
	 * @param p  the predicate
	 */
	private void createReturnType(Predicate p) throws CompilerException {
		
		if (this.predicateClassesGenerated.contains(p))
			return;
		
		String clazz = getClassName(p);
		String fullClassName = packageName + "." + clazz;
		PrintWriter out = new PrintWriter(location.getSrcOut(fullClassName));
		
		Slot[] slots = buildSlots(p);
		out.print("package ");
		out.print(packageName);
		out.println(";");

		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.println(" * This class represents the predicate " + p.getName());
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");

		out.print("public class ");
		out.print(clazz);
		out.println("{");

		// constructor with parameters
		out.print("public ");
		out.print(clazz);
		out.print('(');
		boolean first = true;
		for (Slot slot : slots) {
			if (first)
				first = false;
			else
				out.print(',');
			out.print(slot.type);
			out.print(" ");
			out.print(slot.var);
		}
		out.println("){");
		out.println("super();");
		for (Slot slot : slots) {
			this.printVariableAssignment(out, "this", slot.var, slot.var, null);
		}
		out.println("}");

		// constructor withour params
		out.print("public ");
		out.print(clazz);
		out.print("(){");
		out.println("super();");
		out.println("}");

		// fields
		for (Slot slot : slots) {
			printVariableDeclaration(out, "public", slot.type, slot.var);
		}
		
		out.println("}");
		
		out.close();
		endorseClazz(location, fullClassName);
		
		this.predicateClassesGenerated.add(p);
		
	}
	/**
	 * Create an interface for an external fact store. 
	 * @param out  the writer
	 * @param clazz the interface name
	 * @param pck the package name
	 * @param fs the fact store
	 */
	private void createExternalFactStoreType(PrintWriter out, String clazz, String pck,ExternalFactStore fs) throws CompilerException {
		Predicate p = fs.getPredicate();
		
		Slot[] slots = buildSlots(p);
		out.print("package ");
		out.print(pck);
		out.println(";");
		
		out.println("/**");
		out.println(" * Class generated by the take compiler. ");
		out.print(" * This class represents the external fact store ");
		out.println(fs.getId());
		out.print(" * for the predicate ");
		out.println(p.getName());
		out.print(" * @version ");
		out.println(new Date());
		out.println(" */");

		out.print("public interface ");
		out.print(clazz);
		out.println("{");
		
		out.println(" // Get all instances of this type from the fact store. ");
		out.print("public nz.org.take.rt.ResourceIterator<");
		out.print(packageName );
		out.print(".");
		out.print(getClassName(p));
		out.print("> fetch(");
		boolean f = true;
		for (Slot slot : slots) {
			if (f)
				f = false;
			else
				out.print(',');
			out.print(slot.type);
			out.print(" ");
			out.print(slot.var);
		}
		out.println(");");
		
		out.println("}");
	}
	
	/**
	 * Create a private method for the given query.
	 * @param out
	 * @param className the class owning the method
	 * @param q
	 * @throws CompilerException
	 */
	private void createMethod(PrintWriter out, String className, Query q)	throws CompilerException {
		if (mustCreatePublicMethod(q))
			createPublicMethod(out,q,true,true);
		createPrivateMethod(out,className,q);
	}
	
	/**
	 * Create the annotations store, i.e. a simple file that holds the annotation
	 * data and makes them available at runtime. 
	 * This is a file storing the persistent annotations.
	 */
	private void createAnnotationStore() throws CompilerException {
		Map<String,Map<String,String>> annotations = new HashMap<String,Map<String,String>>();
		// local annotations
		for (KnowledgeElement e:this.kb.getElements()) {
			annotations.put(e.getId(),e.getAnnotations());
		}
		// global annotations
		annotations.put(GLOBAL_ANNOTATION_KEY,kb.getAnnotations());
		
	    XMLEncoder e = new XMLEncoder(location.getResourceOut(packageName,ANNOTATION_STORE));
	    e.writeObject(annotations);
	    e.close();
	}

	
	/**
	 * Create the method returning the annotations. 
	 * This is a file storing the persistent annotations.
	 * @param PrintWriter out
	 */
	private void createAnnotationMethod(PrintWriter out,boolean isInterface) throws CompilerException {

		VelocityContext context = new VelocityContext();
		
		// create method for local annotations
		String templateName = "LocalAnnotationMethod.vm";
		String annotationStore = "/"+packageName.replace('.','/')+'/'+ANNOTATION_STORE;
		context.put("isInterface", isInterface);
		context.put("methodName", "getAnnotations");
		context.put("templatename", templateName);
		context.put("annotationStore", annotationStore);
		context.put("class", className);
		Template template = TemplateManager.getInstance().getTemplate(templateName);
		try {
			template.merge(context, out);
		} catch (Exception x) {
			throw new CompilerException("Problem merging compilation template used to generate annotation method",x);
		} 
		
		// create method for global annotations
		templateName = "GlobalAnnotationMethod.vm";
		template = TemplateManager.getInstance().getTemplate(templateName);
		context.put("templatename", templateName); // override
		context.put("globalAnnotationKey",GLOBAL_ANNOTATION_KEY);
		try {
			template.merge(context, out);
		} catch (Exception x) {
			throw new CompilerException("Problem merging compilation template used to generate global annotation method",x);
		} 
		
		// AnnotationMethod.vm
	    if (!isInterface) {
	    	this.createAnnotationStore();
	    }
	}
	
	/**
	 * Define for which predicates (queries) not to define a public method. 
	 * @param q
	 * @return
	 */
	protected boolean mustCreatePublicMethod(Query q) {
		return true;
	} 
	
	/**
	 * Create a public method for the given query.
	 * @param out
	 * @param q
	 * @param includeBody
	 * @param isStatic
	 * @throws CompilerException
	 */
	@SuppressWarnings("unchecked")
	private void createPublicMethod(PrintWriter out, Query q,boolean includeBody, boolean isStatic)	throws CompilerException {
		Slot[] inSlots = this.buildInputSlots(q);
		Predicate p = q.getPredicate();
		String fragementName = this.getKBFragementClassName(q);

		printMethodComment(out, "Method generated for query " + q, inSlots,
				"an iterator for instances of " + getClassName(p));

		// start header
		out.print("public ");
		if (isStatic)
			out.print("static ");
		this.printGenericType(out,"ResultSet", getClassName(p));
		String methodName = getMethodName(q);
		out.print(methodName);

		printParameters(out, inSlots, true,false,false);
		// end params
		if (includeBody) {
			out.println("{");
			out.print("DerivationController ");
			out.print(this.getVarName4DerivationController());
			out.print(" = new ");
			out.print(this.getDerivationControllerClass());
			out.print('(');
			boolean first = false;
			for (String param:this.getDerivationControllerInitialisationParameters()) {
				if (first)
					first = false;
				else
					out.print(',');
				out.print(param);
			}			
			out.println(");");
			
			//	call the private method
			this.printGenericType(out, "ResultSet", getClassName(p));
			out.print("_result = new ResultSet(");
			out.print(fragementName);
			out.print('.');
			out.print(methodName); 
			printParameters(out, inSlots, false,true,false); 
			out.println(',');
			out.println(this.getVarName4DerivationController());
			out.println(");");
			out.println("return _result;} ");
		}
		else 
			out.println(";");  // abstract method
	}
	

	/**
	 * Create a private method for the given query.
	 * @param out
	 * @param className the class name
	 * @param q
	 * @throws CompilerException
	 */
	@SuppressWarnings("unchecked")
	private void createPrivateMethod(PrintWriter out, String className, Query q) 	throws CompilerException {
		Predicate p = q.getPredicate();
		String methodName = null; 
		
		// try to use plugin
		int i=0;
		while (i<plugins.size() && methodName==null) {				
			CompilerPlugin plugin = plugins.get(i);
			i=i+1;
			if (plugin.supports(q)) {
				methodName = plugin.createMethod(out, q);					
			}				
		}
		if (methodName==null)
			methodName = createPrivateMethod1(out,q);
			
		if (methodName!=null) {
			this.endorseMethod(className,methodName);
			this.removeFromAgenda();
		}		
		else throw new CompilerException("This combination of predicate type and parameter signature is not supported in queries: " + p.getClass() + q.getIOSignatureAsString());
	}
	/**
	 * Create a private method for the given query.
	 * The predicate of the query is defined by rules and facts.
	 * @param out
	 * @param q
	 * @return the method name
	 * @throws CompilerException
	 */
	private String createPrivateMethod1(PrintWriter out, Query q) 	throws CompilerException {
		Slot[] inSlots = this.buildInputSlots(q);
		Slot[] outSlots = this.buildOutputSlots(q);
		Predicate p = q.getPredicate();

		printMethodComment(out, "Method generated for query " + q, inSlots,"an iterator for instances of " + getClassName(p));

		// start header
		this.printGenericType(out, "static ResourceIterator", getClassName(p));
		String methodName = getMethodName(q);
		out.print(methodName);

		printParameters(out, inSlots, true,true,false);
		// end params
		out.println("{");
		
		// variable to cache derivation depth
		out.print("final int _derivationlevel=");
		out.print(this.getVarName4DerivationController());
		out.println(".getDepth();");
		
		
		// these are the rules and facts supporting the predicate
		List<KnowledgeElement> css = kb.getElements(p);

		out.print("ResourceIterator<");
		out.print(getClassName(p));
		out.print("> ");
		out.print(RESULT);
		out.print("= new ");
		out.print("IteratorChain<");
		out.print(getClassName(p));
		out.print(">(");
		out.print(css.size());
		out.println("){");

		out.print("public Object getIteratorOrObject(int pos){");
		out.println("switch(pos){");
		for (int i = 0; i < css.size(); i++) {
			printComment(out, css.get(i));
			out.print("case ");
			out.print(i);
			out.print(":");
			out.print("return ");
			out.print(getMethodName(q, i));
			printParameters(out, inSlots, false,true,true);
			out.println(';');
		}

		out.println("default:");
		out.println("return EmptyIterator.DEFAULT;");
		out.println("} // switch(pos)");
		out.println("} // getIterator()");
		
		out.print("public String getRuleRef(int pos){");
		out.println("switch(pos){");
		for (int i = 0; i < css.size(); i++) {
			printComment(out, css.get(i));
			out.print("case ");
			out.print(i);
			out.print(":");
			out.print("return \"");
			out.print(getRuleRef(css.get(i)));
			out.println("\";");
		}

		out.println("default:");
		out.println("return \"\";");
		out.println("} // switch(pos)");
		out.println("} // getRuleRef()");
		out.println("};"); // end inner class
		out.print("return "); // end inner class
		out.println(RESULT);
		out.println(";}");
		
		// generate a method for each clause set
		for (int i = 0; i < css.size(); i++) {
			createMethod(out, q, inSlots, outSlots, css.get(i), i);
		}
		
		return methodName;

	}

	// create private method
	private void createMethod(PrintWriter out, Query q, Slot[] islots,Slot[] oslots, KnowledgeElement cs, int i) throws CompilerException {
		Predicate p = q.getPredicate();
		printMethodComment(out, "Method generated for query " + q, islots,
				"an iterator for instances of " + getClassName(p));

		// facts are handled differently to minimize memory consumption
		if (cs instanceof Fact) {
			out.print("private static ");
			out.print(getClassName(q.getPredicate()));
			out.print(' ');
		}
		else {
			out.print("private static ResourceIterator<");
			out.print(getClassName(q.getPredicate()));
			out.print("> ");
		}
		
		
		out.print(getMethodName(q, i));
		printParameters(out, islots, true,true,false);
		out.print("{");

		// generate method body
	
		if (cs instanceof Fact) {
			createBody(out, q, islots, oslots, (Fact) cs);
		} 
		else if (cs instanceof ExternalFactStore){
			createBody(out, q, islots, oslots, (ExternalFactStore) cs);
		}
		else if (cs instanceof DerivationRule) {
			DerivationRule r = (DerivationRule)cs;
			if (r.getBody().size()==0)
				createBodyForRuleWithEmptyBody(out, q, islots, oslots, (DerivationRule) cs);
			else
				createBody(out, q, islots, oslots, (DerivationRule) cs);
		} else {
			out.print("// this clause set type is not yet supported: ");
			out.println(cs.getClass());

		}

		out.println("}");
	}
	/**
	 * Create a proof for a query. 
	 * @param out - a print writer
	 * @param q - the query
	 * @param islots - the input slots (known)
	 * @param oslots - the output slots (to be bound)
	 * @param f - the fact
	 * @throws CompilerException
	 */
	private void createBody(PrintWriter out, Query q, Slot[] islots,
			Slot[] oslots, Fact f) throws CompilerException {
		
		// log 
		printLogStatement(out,f,q.getInputParams(),islots);
		
		// start creating return var
		Predicate p = q.getPredicate();
		out.print(getClassName(p));
		out.print(" ");
		out.print(RESULT);
		out.print("=");
		printContructorInvocation(out, getClassName(p), null);
		out.println(";");

		// start initializing return var
		for (Slot slot : islots) {
			out.print(RESULT);
			out.print(".");
			out.print(slot.var);
			out.print("=");
			out.print(slot.var);
			out.println(";");
		}

		if (islots.length == 0)
			out.println("if (true) {");
		else {
			out.print("if (");
			boolean first = true;
			for (Slot slot : islots) {
				if (first)
					first = false;
				else
					out.print("&&");
				out.print(slot.var);
				out.print(".equals(");
				Term t = f.getTerms()[slot.position];
				assert (t instanceof Constant);
				out.print(getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant)t));
				out.print(")");
			}
			out.println("){");
		}

		for (Slot slot : oslots) {
			out.print(RESULT);
			out.print(".");
			out.print(slot.var);
			out.print("=");
			Term t = f.getTerms()[slot.position];
			assert (t instanceof Constant);
			out.print(getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant) t));
			out.println(";");
		}
		out.print("return ");
		out.print(RESULT);
		out.println(';');
		out.println("}");
		out.print("return null;");

	}

	/**
	 * Create a proof for a query.
	 * @param out a print writer
	 * @param q the query
	 * @param islots the input slots (known)
	 * @param oslots the output slots (to be bound)
	 * @param fs the fact store
	 * @throws CompilerException
	 */
	private void createBody(PrintWriter out, Query q, Slot[] islots,
			Slot[] oslots, ExternalFactStore fs) throws CompilerException {
		
		String regClass = this.getNameGenerator().getFactStoreRegistryClassName();
		
		String factStoreRef = regClass +'.'+fs.getId();
		// print log statement
		printLogStatement(out,fs,q.getInputParams(),islots);
		
		
		// invoke external fact set
		out.print("return ");
		out.print(factStoreRef);
		out.print('.');
		out.print("fetch");
		out.print('(');
		// parameter list
		boolean f = true;
		for (int i=0;i<fs.getPredicate().getSlotTypes().length;i++) {
			if (f)
				f = false;
			else 
				out.print(',');
			// see whether we can use a parameter, otherwise use null
			String param = "null";
			for (int j=0;j<islots.length;j++) {
				// bugfix by Jens 22/11/07
				// thanks to Christoph Walzer for reporting problems in scenario8
				if (i==islots[j].position) {
					param = islots[j].name;
					break;
				}					
			}
			out.print(param);
			
		}
		
		
		out.print(");");

	}

	/**
	 * Create a proof for a query.
	 * @param out a print writer
	 * @param q the query
	 * @param islots the input slots (known)
	 * @param oslots the output slots (to be bound)
	 * @param r the rule
	 * @throws CompilerException
	 */
	private void createBody(PrintWriter out, Query q, Slot[] islots,Slot[] oslots, DerivationRule r) throws CompilerException {
		
		// print log statement
		printLogStatement(out,r,q.getInputParams(),islots);
		
		
		// the concrete bindings for this rule
		Collection<Term> allTerms = this.getAllTerms(r);
		Bindings bindings = new Bindings(allTerms,this.getNameGenerator());
		
		// compute initial bindings
		Fact head = r.getHead();
		Term[] terms = head.getTerms();
		
		// compare constants in rule head with constants provided in parameters
		// if they don't match, return empty iterator
		int compCount = 0;
		for (int i=0;i<terms.length;i++) {
			if (terms[i] instanceof Constant) {
				for (int j=0;j<islots.length;j++) {
					if (islots[j].position==i) {
						if (compCount==0) {
							out.println("// comparing constants in rule head with parameters");
							out.print("if (");
						}
						if (compCount>0)
							out.print(" || ");						
						printComparison(out,getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant)terms[i]),islots[j].name,true,terms[i].getType());
						compCount = compCount+1;
					}
				}
			}
		}
		if (compCount>0) {
			out.println("){");
			out.println("return EmptyIterator.DEFAULT;");
			out.println("}");
		}
			
		
		// bind all input slots to variables of the current rule
		for (int i = 0; i < islots.length; i++) {
			bindings.put(terms[islots[i].position], islots[i].var);
		}
		// bind all constant terms
		for (Term t:getAllTerms(r)) { // changed 14/08/07 - all constants must be picked up
			if (t instanceof Constant) {
				bindings.put(t,getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant)t));
			}
		}

		String bindingsClass = this.getBindingClassName(r);
		// all variable names of the current rule
		Map<Term, String> refs = createBindingClass(out, r);
		out.print("final ");
		out.print(bindingsClass);
		out.print(" ");
		out.print("bindings");
		out.print(" = ");
		this.printContructorInvocation(out, bindingsClass, null);
		out.println(';');

		// assign input vars
		for (Map.Entry<Term, String> refEntry : refs.entrySet()) {
			String var = bindings.getRef(refEntry.getKey());
			if (var != null) {				
				printVariableAssignment(out, "bindings",refEntry.getValue(),var);
				bindings.assigned(refEntry.getKey());
				//  replace bindings by references to fields in bindings - changed 19/09/07
				if (refEntry.getKey() instanceof ComplexTerm) {
					bindings.put(refEntry.getKey(), "bindings"+'.'+refEntry.getValue());
				}
			}
		}

		List<Fact> literals = new ArrayList<Fact>();
		List<ExpressionPrerequisite> expressions = new ArrayList<ExpressionPrerequisite>();
		Fact previousFact = null;
		literals.addAll(r.getFactPrerequisites());
		literals.add(r.getHead());
		expressions.addAll(r.getExpressionPrerequisites());
	
		TmpVarGenerator varGen = new TmpVarGenerator();
		String iteratorName = null, className = null, previousIteratorName = null, previousClassName = null;
		boolean first = true;
		int counter = 1;
		for (Fact prereq : literals) {
			
			// check for expressions we can evaluate
			// this could be optimised by ordering them, evaluating simpler expressions
			// first
			for (Iterator<ExpressionPrerequisite> iter = expressions.iterator();iter.hasNext();) {
				ExpressionPrerequisite xp = iter.next();
				List<String> paramRefs = checkForBoundParameter(xp,bindings);
				className = this.expressionPrereqMethodTypes.get(xp);
				if (className!=null && paramRefs!=null) { // reuse if already generated, params must be bound
					iteratorName = varGen.nextTmpVar("iterator");
					this.printOneLineComment(out, "code for prereq ", prereq);
					this.printGenericType(out, "ResourceIterator", className);
					
					out.print(iteratorName);
					out.print(" = ");
					if (first) {
						this.expressionPrereqMethodRefs.get(xp);
						first = false;
						printInvocation(out,xp,paramRefs,true,true);
					}
					else {
						out.print("// TODO");
					}
					out.println(";");
					iter.remove();
					previousFact = null;
					previousIteratorName = iteratorName;
					previousClassName = className;
				}
			}
			
			iteratorName = varGen.nextTmpVar("iterator");
			className = getClassName(prereq);
			this.printOneLineComment(out, "code for prereq ", prereq);
			out.print("final ");
			this.printGenericType(out, "ResourceIterator", className);

			out.print(iteratorName);
			out.print(" = ");
			
			// add constants to bindings
			// bind all constant terms
			for (Term t:prereq.getTerms()) {
				if (t instanceof Constant) {
					bindings.put(t,getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant)t));
				}
			}

			/*
			 * if (prereq!=r.getHead()) addToAgenda(query);
			 */
			if (first) {
				// call method
				// unification: find the input params known
				QueryRef query = buildQuery(prereq, bindings);
				first = false;
				printInvocation(out, query,true,true);
				counter = counter+1;
				out.println(";");
				if (prereq != r.getHead()) {
					addToAgenda(query);
				}
			} else {
				printContructorInvocation2(out, "NestedIterator",
						previousClassName, className, previousIteratorName);
				out.println("{");
				out.print("public ResourceIterator<");
				out.print(className);
				out.print("> getNextIterator(");
				out.print(previousClassName);
				out.print(" object");
				out.println("){");
				// bind params from previous iterator
				// here we set the attributes of the bindings object
				if (previousFact!=null) {  // would be null if previous was expression prereq
					Term[] pterms = previousFact.getTerms();
					for (int i = 0; i < pterms.length; i++) {
						Term t = pterms[i];
						Slot slot = this.buildSlot(previousFact.getPredicate(),	i);
						
						// the type of the term and the type of the predicate slot might be different (but compatible - the term types must be a subtype
						// of the slot type. If they are different, a cast must be generated
						
						Class termType = t.getType();
						Class slotType = previousFact.getPredicate().getSlotTypes()[i];
						String cast = termType.equals(slotType)?null:this.getTypeName(termType);
						String ref = refs.get(t);
						if (t instanceof Variable) {
							Variable vt = (Variable) t;						
							printVariableAssignment(out, "bindings",ref,"object", slot.var,cast);
							bindings.put(vt, refs.get(vt));
							bindings.assigned(vt);
						} else if (t instanceof ComplexTerm) {
							ComplexTerm vt = (ComplexTerm) t;						
							printVariableAssignment(out, "bindings",ref,"object", slot.var,cast);
							// bindings.put(vt, refs.get(vt));	// changed 19/09/07 - this avoids expensive method class
							bindings.put(vt, "bindings"+'.'+ref);	
							bindings.assigned(vt);
						} else if (t instanceof Constant) {
							Constant vt = (Constant) t;						
							printVariableAssignment(out, "bindings",ref,getRef(this.getNameGenerator().getConstantRegistryClassName(),vt),null,cast);
							bindings.put(vt, refs.get(vt));			
							bindings.assigned(vt);
						}
					}
				}
				
				
				// print bindings for complex terms that are based on existing terms 
				// ===== code starts to fix issue 22 =====");
				for (Map.Entry<Term, String> refEntry : refs.entrySet()) {
					String var = bindings.getRef(refEntry.getKey());
					if (var != null) {				
						//  replace bindings by references to fields in bindings - changed 19/09/07
						if (refEntry.getKey() instanceof ComplexTerm && !bindings.isAssigned(refEntry.getKey())) {
							printVariableAssignment(out, "bindings",refEntry.getValue(),"bindings."+var);
							bindings.assigned(refEntry.getKey());
						}
					}
				}
				//===== code ends to fix issue 22 =====

				
				// build method call
				// here we call the method that supplies the next iterator
				boolean[] sig = new boolean[prereq.getPredicate()	.getSlotTypes().length];
				List<String> params = new ArrayList<String>(sig.length);
				for (int j = 0; j < sig.length; j++) {
					// bind known variables
					// problem
					//String expr = refs.get(prereq.getTerms()[j]);
					// terms  that have been bound
					sig[j] = bindings.hasBinding(prereq.getTerms()[j]);
					if (sig[j]) {
						params	.add("bindings."+refs.get(prereq.getTerms()[j]));
					}
				}
				// TODO
				QueryRef nextQuery = new QueryRef(prereq.getPredicate(), sig,params);
				
				out.print("return ");
				if (prereq == r.getHead()) {
					out.print("new SingletonIterator(");
					printConstructorInvocation(out, nextQuery);
					out.println(")");
				} else {
					addToAgenda(nextQuery);
					// the method that must be called
					printInvocation(out, nextQuery,true,true);
					counter = counter+1;
				}
				out.println(";");
				out.println("}");

				out.println("};");
			}
			previousIteratorName = iteratorName;
			previousClassName = className;
			previousFact = prereq;
			
			// createExpressionInvocation(out,expressions,bindings,varGen);
		}
		// FIXME: enable
		/*
		if (!expressions.isEmpty()) {
			throw new CompilerException("There are " + expressions.size() + " unevaluated conditions left, for instance " + expressions.get(0));
		}
		*/

		out.print("return ");
		out.print(iteratorName);
		out.println(";");
	}
	// check whether all variable terms occuring in the expression have bindings
	// if so, return them as a list.
	// if there are some without bindings, return null
   private List<String> checkForBoundParameter(Expression x,Bindings bindings) {
		Collection<Variable> vars = x.getVariables();
	   	List<String> params = new ArrayList<String>(vars.size());
	   	for (Variable v:vars) {
	   		String arg = bindings.getRef(v);
	   		if (arg==null) {
	   			return null;
	   		}
	   		else {
	   			params.add(arg);
	   		}
	   	}
		return params;
	}

private void _createExpressionInvocation(PrintWriter out,	List<ExpressionPrerequisite> expressions, Bindings bindings,TmpVarGenerator varGen) {
		// check whether we can evaluate expressions here
		for (Iterator<ExpressionPrerequisite> iter =expressions.iterator();iter.hasNext();) {
			ExpressionPrerequisite exprPrereq = iter.next();
			if (bindings.hasBindings(exprPrereq.getVariables())) {
				this.printOneLineComment(out, "evaluating expression " + exprPrereq);
				List<String> refs = new ArrayList<String>(exprPrereq.getVariables().size());
				for (Variable var:exprPrereq.getVariables()) {
					refs.add(bindings.getRef(var));
				}
				this.printOneLineComment(out, "with parameters " + refs);
				// boolean control variable
				String var = varGen.nextTmpVar("chkExprResult");
				this.printVariableDeclaration(out, null, "boolean", var, "false");
				String expressionField = this.expressionDefs.get(exprPrereq);
				exprPrereq.generateInvocationCode(out,var,nameGenerator.getExpressionRegistryClassName(),expressionField,varGen,refs);
				
				// check, and if it fails, return empty iterator
				out.print("if (!");
				out.print(var);
				out.println(") {");
				out.println("return EmptyIterator.DEFAULT;");
				out.println("}");
				
				// remove from list - has been executed
				iter.remove();
			}
		}
		
	}

/**
	 * Indicates whether the publicAgenda is empty.
	 * 
	 * @return Returns a boolean.
	 */
	private boolean isAgendaEmpty() {
		return publicAgenda.isEmpty();
	}

	/**
	 * Returns the next query.
	 * 
	 * @return a query
	 */
	private Query getNextQuery() {
		return publicAgenda.get(0);
	}

	/**
	 * Remove the current query.
	 * 
	 * @return a query
	 */
	private void removeFromAgenda() {
		Query q = publicAgenda.remove(0);
		done.add(q);
	}

	/**
	 * Add a query to the publicAgenda.
	 * 
	 * @param q
	 *            a query
	 */
	void addToAgenda(Query q) {
		if (!done.contains(q) && !publicAgenda.contains(q)) {
			publicAgenda.add(q);			
			if (getLogger().isDebugEnabled()) {
				getLogger().debug("Adding query to agenda: " + q);
			}
		}
	}

	/**
	 * Get the name generator.
	 * 
	 * @return Returns the nameGenerator.
	 */
	public NameGenerator getNameGenerator() {
		return nameGenerator;
	}

	/**
	 * Set the name generator.
	 * 
	 * @param nameGenerator
	 *            The nameGenerator to set.
	 */
	public void setNameGenerator(NameGenerator nameGenerator) {
		this.nameGenerator = nameGenerator;
	}

	/**
	 * Get the class name for the bindings used in the method generated for a
	 * rule. 
	 * @param r a rule
	 * @return a string
	 */
	private String getBindingClassName(DerivationRule r) {
		String name = bindingClassNames.get(r);
		if (name == null) {
			name = "bindingsInRule" + this.bindingClassCounter;
			bindingClassNames.put(r, name);
			bindingClassCounter = bindingClassCounter + 1;
		}
		return name;
	}

	/**
	 * Add a source code transformer.
	 * @param t
	 */
	public void add(SourceTransformation t) {
		this.transformations.add(t);
	}
	
	/**
	 * Print the import stattements.
	 * @param out a print writer
	 */
	private void printImports(PrintWriter out) {
		if (this.importStatements!=null) {
			for (String s:this.importStatements) {
				out.print("import ");
				out.print(s);
				out.println(";");
			}
		}
	}

	/**
	 * Remove a source code transformer.
	 * @param t
	 */
	public void remove(SourceTransformation t) {
		this.transformations.remove(t);
	}

	/**
	 * Get a list of source transformers installed.
	 * @return a list of transformations
	 */
	public List<SourceTransformation> getSourceTransformers() {
		return this.transformations;
	}

	public String getDerivationControllerClass() {
		return derivationControllerClass;
	}

	public void setDerivationControllerClass(String derivationControllerClass) {
		this.derivationControllerClass = derivationControllerClass;
	}

	public String[] getDerivationControllerInitialisationParameters() {
		return derivationControllerInitialisationParameters;
	}

	public void setDerivationControllerInitialisationParameters(
			String[] derivationControllerInitialisationParameters) {
		this.derivationControllerInitialisationParameters = derivationControllerInitialisationParameters;
	}

	public String getVarName4DerivationController() {
		return varName4DerivationController;
	}

	public void setVarName4DerivationController(String varName4DerivationController) {
		this.varName4DerivationController = varName4DerivationController;
	}

	@Override
	public KnowledgeBase getKB() {
		return kb;
	}
	/**
	 * Install a plugin.
	 * @param plugin a new compiler plugin
	 */
	public void install(CompilerPlugin plugin) {
		this.plugins.add(plugin);
	}
	/**
	 * Install an aggregation function generator.
	 * @param gen a new generator for aggregation functions
	 */
	public void install(AggregationFunctionGenerator gen) {
		this.aggregationFunctionGenerators.put(gen.getSupportedAggregation(),gen);
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String[] getInterfaceNames() {
		return interfaceNames;
	}

	public void setInterfaceNames(String...  interfaceNames) {
		this.interfaceNames = interfaceNames;
	}

	public Location getLocation() {
		return location;
	}

	public void setLocation(Location location) {
		this.location = location;
	}

	public String getPackageName() {
		return packageName;
	}

	public void setPackageName(String packageName) {
		this.packageName = packageName;
	}

	public boolean isGenerateDataClassesForQueryPredicates() {
		return generateDataClassesForQueryPredicates;
	}

	public void setGenerateDataClassesForQueryPredicates(
			boolean generateDataClassesForQueryPredicates) {
		this.generateDataClassesForQueryPredicates = generateDataClassesForQueryPredicates;
	}
	private  Set<Predicate> getPublicPredicates() {
		if (this.publicPredicates==null) {
			publicPredicates = new HashSet<Predicate>();
			for (Query q:this.kb.getQueries()) {
				publicPredicates.add(q.getPredicate());
			}
		}
		return publicPredicates;
	}
	
	private  Map<String,ExternalFactStore> getExternalFactStores() {
		if (this.externalFactStores==null) {
			externalFactStores = new HashMap<String,ExternalFactStore>();
			for (KnowledgeElement e:kb.getElements()) {
				if (e instanceof ExternalFactStore) {
					ExternalFactStore fs = (ExternalFactStore)e;
					externalFactStores.put(fs.getId(),fs);
				}
			}
		}
		return externalFactStores;
	}
	

	public String[] getImportStatements() {
		return importStatements;
	}

	public void setImportStatements(String... importStatements) {
		this.importStatements = importStatements;
	}
	private String getExternalDataStoreName(ExternalFactStore ds) {
		boolean exclusive = true;
		String id = ds.getId();
		Predicate p = ds.getPredicate();
		for (Map.Entry<String,ExternalFactStore> e:this.getExternalFactStores().entrySet()){
			if (id!=e.getKey() && p.equals(e.getValue())) {
				exclusive = false;
				break;
			}
				
		}
		String pClassName = "ExternalFactStore4"+getClassName(ds.getPredicate());
		if (!exclusive) {
			pClassName = pClassName + '_' + id;
		}
		return pClassName;
	}

	private PrintWriter getPrintWriter(String cn) throws CompilerException {
		PrintWriter out = this.classWriters.get(cn);
		if (out==null) {
			String fullClassName = packageName + "." + cn;
			out = new PrintWriter(location.getSrcOut(fullClassName));
			classWriters.put(cn,out);
			// print class declaration to new writer
			createKBFragmentClass(out,cn,this.getPackageName());
		}
		return out;
	}

	/**
	 * Create a proof for a query.
	 * @param out a print writer
	 * @param q the query
	 * @param islots the input slots (known)
	 * @param oslots the output slots (to be bound)
	 * @param r the rule
	 * @throws CompilerException
	 */
	private void createBodyForRuleWithEmptyBody(PrintWriter out, Query q, Slot[] islots,Slot[] oslots, DerivationRule r) throws CompilerException {
		
		// print log statement
		printLogStatement(out,r,q.getInputParams(),islots);
		
		out.println("// rule with empty body");
		
		// the concrete bindings for this rule
		Collection<Term> allTerms = this.getAllTerms(r);
		Bindings bindings = new Bindings(allTerms,this.getNameGenerator());
		
		// compute initial bindings
		Fact head = r.getHead();
		Term[] terms = head.getTerms();
		
		// compare constants in rule head with constants provided in parameters
		// if they don't match, return empty iterator
		int compCount = 0;
		for (int i=0;i<terms.length;i++) {
			if (terms[i] instanceof Constant) {
				for (int j=0;j<islots.length;j++) {
					if (islots[j].position==i) {
						if (compCount==0) {
							out.println("// comparing constants in rule head with parameters");
							out.print("if (");
						}
						if (compCount>0)
							out.print(" || ");						
						printComparison(out,getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant)terms[i]),islots[j].name,true,terms[i].getType());
						compCount = compCount+1;
					}
				}
			}
		}
		if (compCount>0) {
			out.println("){");
			out.println("return EmptyIterator.DEFAULT;");
			out.println("}");
		}
			
		
		// bind all input slots to variables of the current rule
		for (int i = 0; i < islots.length; i++) {
			bindings.put(terms[islots[i].position], islots[i].var);
		}
		// bind all constant terms
		for (Term t:getAllTerms(r)) { 
			if (t instanceof Constant) {
				bindings.put(t,getRef(this.getNameGenerator().getConstantRegistryClassName(),(Constant)t));
			}
		}
		
		// return a single object 
		Predicate p = q.getPredicate();
		out.print(getClassName(p));
		out.print(" ");
		out.print(RESULT);
		out.print("=");
		printContructorInvocation(out, getClassName(p), null);
		out.println(";");
		
		// assign values
		for (int i=0;i<terms.length;i++) {
			out.print(RESULT);
			out.print('.');
			out.print(this.getNameGenerator().getVariableNameForSlot(p,i));
			out.print(" = ");
			out.print(bindings.getRef(terms[i]));
			out.println(';');
		}
		
		out.print("return ");
		out.print("new SingletonIterator<");
		out.print(this.getNameGenerator().getClassName(q.getPredicate()));
		out.print(">(");
		out.print(RESULT);
		out.print(");");		
	}
	
	private Collection<Constant> findConstants() {
		final Collection<Constant> constants = new HashSet<Constant>();
		AbstractKnowledgeBaseVisitor lookup = new AbstractKnowledgeBaseVisitor() {
			public boolean visit(Constant t) {
				super.visit(t);
				if (!t.isLiteral())
					constants.add(t);
				return true;
			}			
		};
		kb.accept(lookup);
		return constants;
	}
	
	private Collection<AggregationFunction> findAggregationFunctions() {
		final Collection<AggregationFunction> functions = new HashSet<AggregationFunction>();
		// aggregation functions are not yet supported
		/**
		AbstractKnowledgeBaseVisitor lookup = new AbstractKnowledgeBaseVisitor() {
			public boolean visit(ComplexTerm t) {
				super.visit(t);
				if (t.getFunction() instanceof AggregationFunction)
					functions.add((AggregationFunction)t.getFunction());
				return true;
			}			
		};
		kb.accept(lookup);
		*/
		return functions;
	}
	private Collection<ExternalFactStore> findExternalFactStores() {
		final Collection<ExternalFactStore> stores = new HashSet<ExternalFactStore>();
		KnowledgeBaseVisitor lookup = new AbstractKnowledgeBaseVisitor() {
			public boolean visit(ExternalFactStore fs) {
				super.visit(fs);
				stores.add(fs);
				return true;
			}
			public boolean visit(DerivationRule r) {
				return false;
			}	
			public boolean visit(Fact f) {
				return false;
			}	
			public boolean visit(Query q) {
				return false;
			}	
		};
		kb.accept(lookup);
		return stores;
	}

	private Collection<Expression> findExpressions() {
		final Collection<Expression> stores = new HashSet<Expression>();
		KnowledgeBaseVisitor lookup = new AbstractKnowledgeBaseVisitor() {
			@Override
			public boolean visit(ComplexTerm t) {
				stores.add(t);
				return false;
			}
			@Override
			public boolean visit(ExpressionPrerequisite q) {
				stores.add(q);
				return false;
			}

		};
		kb.accept(lookup);
		return stores;
	}
	public boolean isAutoAnnotate() {
		return autoAnnotate;
	}

	public void setAutoAnnotate(boolean autoAnnotate) {
		this.autoAnnotate = autoAnnotate;
	}
	
	/**
	 * Print the code used to invoke the method representing a query.
	 * @param out a print writer
	 * @param queryRef the query + the parameters used
	 */
	protected void printInvocation(PrintWriter out, ExpressionPrerequisite prereq,List<String> paramRefs, boolean includeExplanation, boolean increaseLevel) {
		out.print(this.expressionPrereqMethodRefs.get(prereq));
		out.print("(");
		boolean f = true;
		for (String param : paramRefs) {
			if (f)
				f = false;
			else
				out.print(',');
			out.print(param);
		}
		// add reference to explanation
		if (includeExplanation) {
			if (f)
				f = false;
			else
				out.print(',');
			out.print(this.getVarName4DerivationController());
			if (increaseLevel) {
				out.print(".increaseDepth()");
			}
		}
		out.print(")");
	}
}
